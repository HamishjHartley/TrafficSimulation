package intersection_sim;
import java.util.ArrayList;
import java.util.NoSuchElementException;
import custom_exceptions.PlateNumberFormatException;

public class Vehicle extends Thread{

	private String numberPlate;
	private int crossTime;
	private int direction; 
	private Boolean crossingStatus;
	private int length;
	private int segment; 
	private int emissionsPerSecond; 
	private String vehicleType;
	private long initialisationTime;
	private long crossingStatusTime;
	private Boolean isGreen = false;
	private Phase phase;

	public Vehicle(String numberPlate, String vehicleType, int crossTime, int direction, int length, int emissionsPerSecond ,
			Boolean crossingStatus, int segment, Phase phase)  throws PlateNumberFormatException {

		// Check if either the number plate or the vehicle type is null
		if (numberPlate == null || vehicleType == null) {
			throw new IllegalArgumentException();
		}

		// Plate number and vehicle type must be provided
		if (numberPlate.length() == 0 || vehicleType.length() == 0) {
			throw new IllegalStateException("Cannot have blank plate number or vehicle type");
		}

		// Check if the number plate format is correct
		if (!isNumberPlateCorrect(numberPlate)) {
			throw new PlateNumberFormatException(numberPlate);
		}

		// Check if the cross time is 0 or negative
		if (crossTime <= 0) {
			throw new IllegalStateException("Cross time must be greater than 0s");
		}

		// Check if the direction is negative
		if (direction < 0) {
			throw new IllegalStateException("Directions can only be a positive int");
		}

		// Check if the length is 0 or negative
		if (length <= 0) {
			throw new IllegalStateException("Length can only be a positive int");
		}

		// Check if the emissions are negative (they can be 0 for electric cars for
		// example)
		if (emissionsPerSecond  < 0) {
			throw new IllegalStateException("Emissions must be greater or equal than 0");
		}

		// Check if the emissions are negative (they can be 0 for electric cars for
		// example)
		if (segment < 0) {
			throw new IllegalStateException("Segment must be greater or equal than 0");
		}

		this.numberPlate = numberPlate;
		this.crossTime = crossTime;
		this.direction = direction;
		this.crossingStatus = crossingStatus;
		this.length = length;
		this.segment = segment;
		this.emissionsPerSecond  = emissionsPerSecond ;
		this.vehicleType = vehicleType;
		initialisationTime = System.currentTimeMillis(); //Current running time in s
		crossingStatusTime = initialisationTime; 
		this.phase = phase;
	}

	/**
	 * Check if the numberplate follows the Great Britain number plate standard set
	 * after September of 2001 this is two letters, followed by two numbers,
	 * followed by a space and then three letters (eg: XX23 XXX).
	 * 
	 * @param numberplate
	 * @return true if compliant
	 */
	private Boolean isNumberPlateCorrect(String numberPlate) {

		// Check if the number plate length (It has to be 8, 7 chars and 1 space)
		if (numberPlate.length() == 8) {

			// Index 0, 1, 5, 6 and 7 must be letters
			if (Character.isLetter(numberPlate.charAt(0)) && Character.isLetter(numberPlate.charAt(1))
					&& Character.isLetter(numberPlate.charAt(5)) && Character.isLetter(numberPlate.charAt(6))
					&& Character.isLetter(numberPlate.charAt(7))) {

				// Index 2 and 3 must be letters
				if (Character.isDigit(numberPlate.charAt(2)) && Character.isDigit(numberPlate.charAt(3))) {

					// Index 4 must be a space
					if (numberPlate.charAt(4) == ' ') {

						return true;
					}
				}
			}
		}
		return false;
	}

	/**
	 * Return number plate of the vehicle.
	 * 
	 * @return number plate
	 */
	public String getNumberPlate() {
		return numberPlate;
	}

	/**
	 *  Return the total cross time of the vehicle.
	 *  
	 * @return crosstime
	 */
	public int getCrossTime() {
		return crossTime;
	}

	/**
	 * Return an integer that represents the direction where the car is heading.
	 * 1 for left, 2 for straight and 3 for right.
	 * 
	 * @return direction
	 */
	public int getDirection() {
		return direction;
	}

	/**
	 * Return crossing status of the vehicle, true for crossed.
	 * 
	 * @return crossing status
	 */
	public boolean isCrossed() {
		return crossingStatus;
	}

	/**
	 * Return vehicle length
	 * 
	 * @return length
	 */
	public int getLength() {
		return length;
	}

	/**
	 * Return the segment the vehicle is currently at.
	 * 
	 * @return segment the vehicle is at
	 */
	public int getSegment() {
		return segment;
	}

	/**
	 * Return emissions per second generated by this vehicle.
	 * 
	 * @return emissions per second
	 */
	public int getEmissions() {
		return emissionsPerSecond;
	}

	/**
	 * Return the vehicle type. E.g: Car, Truck, Bus...
	 * 
	 * @return vehicle type
	 */
	public String getVehicleType() {
		return vehicleType;
	}

	/**
	 * Returns phase the vehicle is assigned to cross the intersection.
	 * 
	 * @return vehicle phase
	 */
	public Phase getPhase() {
		return phase;
	}

	/**
	 * Set the crossing status. True if the vehicle has crossed the intersection
	 * 
	 * @param isCrossed
	 */
	public void setCrossingStatus(Boolean isCrossed) {

		// If the vehicle was waiting to cross, and now is set to "crossed", stop the timer to compute the total
		// C02 emissions, and change its status to "crossed".
		if(!crossingStatus && isCrossed) {
			crossingStatusTime = System.currentTimeMillis();
			crossingStatus = true;
		}
		else {
			crossingStatus = isCrossed;
		}
	}

	/**
	 * Returns total amount of C02 emitted since the vehicle was created. This is emissions per second multiplied by the time the vehicle
	 * has been waiting in the intersection.
	 * 
	 * @return total C02 emissions
	 */
	public int getCO2Emitted() {
		// If the car has already crossingStatus, return the total CO2 until the time it crossingStatus
		if(crossingStatus) {
			int elapsedTime = (int)(crossingStatusTime - initialisationTime);
			int CO2Emitted = elapsedTime * emissionsPerSecond;
			return CO2Emitted;
		}
		// If the car is still in the queue, return the total CO2 until now
		else {
			long currentTime = System.currentTimeMillis();
			long elapsedTime = (currentTime - initialisationTime) / 1000;
			int CO2Emitted = (int)(elapsedTime * emissionsPerSecond);
			return CO2Emitted;
		}
	}

	/**
	 * Set the vehicle to green light, indicating the queue it is currently at, can cross the intersection.
	 * 
	 * @param isGreen
	 */
	public void isGreenLight(Boolean isGreen) {
		this.isGreen = isGreen;
	}

	/**
	 * Print the vehicle relevant information
	 */
	public String toString() {
		String vehicleInfo = "Type of vehicle: " + vehicleType + "\n" + "Number plate: " + numberPlate + "\n"
				+ "Cross time: " + crossTime + "\n" + "Direction: " + direction + "\n" + "crossingStatus: " + crossingStatus + "\n"
				+ "Length: " + length + "\n" + "Segment: " + segment + "\n" + "Emission per second: " + emissionsPerSecond;

		return vehicleInfo;
	}

	@Override
	public void run() {
		Lane currLane;
		
		// 1. Check if the vehicle is the first in its queue
		outerLoop:
		while(true) {
			synchronized(phase) {
				// Get all lanes assigned to vehicle's phase
				ArrayList<Lane> lanes = phase.getLanes();
				// Check for all the queues, if the vehicle is the first
				for(Lane currentLane : lanes) {
					try {
						String vehicleNumberPlate = currentLane.getFirstVehicleInQueue().getNumberPlate();
						// If the vehicle is the first on one of the queues, save the queue and move on to the next step
						if(vehicleNumberPlate.equals(numberPlate)) {
							currLane = currentLane;
							break outerLoop;
						}
					}catch(NoSuchElementException e) {
						continue;
					}
				}
				// If the vehicle is not the first in any of its phase queues, wait
				try {
					phase.wait();
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		}
		// 2. Check if the vehicle's phase is activated, by checking if the street light color is green
		while(true) {
			synchronized(phase) {
				// If green, move on to the next step
				if(isGreen) {
					break;
				}
				// If not, wait
				else {
					try {
						phase.wait();
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
			}

		}
		// 3. Sleep this vehicle thread during its crossing time
		try {
			Thread.sleep(crossTime*1000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		// 4. Update the vehicle's status and update the lane's queue
		synchronized(phase) {
			setCrossingStatus(true); 						// Set vehicle as crossed
			phase.addVehicleAsCrossed(numberPlate);			// Add the vehile's plate number to the phase's buffer to update the GUI
			currLane.removeFirstVehicleInQueue();			// Remove vehicle from the queue of waiting cars
			
			phase.notifyAll();								// Notify all the vehicle threads in this phase
		}
		// 5. Thread dies
	}
}
